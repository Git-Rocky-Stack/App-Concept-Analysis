# Strategia-X: Technical Architecture & Technology Specification

## 1. Executive Summary
Strategia-X is a progressive web application (PWA) designed to function as an AI-powered market analyst. It leverages Generative AI to simulate market research, validate app concepts, and project financial outcomes. The application is built on a "Local-First" architecture, ensuring data privacy and rapid interaction times, while utilizing a hybrid shell for mobile deployment capability.

## 2. Project Scope
The scope of the technical implementation encompasses:
*   **Generative AI Integration:** Direct interfacing with Google Gemini 2.5 Flash and Gemini 2.5 Flash Image models.
*   **Data Visualization:** Real-time rendering of financial growth charts and SWOT grids.
*   **Business Logic:** Client-side calculation of virality coefficients and ad revenue potential.
*   **Persistence:** LocalStorage-based state management for user sessions and saved data.
*   **Hybrid Bridge:** Two-way communication layers between the React webview and Native Android/iOS shells for ad monetization.

---

## 3. Technology Stack

### Core Frameworks & Languages
*   **Frontend Library:** React 19 (utilizing Hooks, Suspense, and Lazy Loading).
*   **Language:** TypeScript 5.5 (Strict Mode enabled for type safety).
*   **Build Tool:** Vite (Optimized for ES Modules and HMR).
*   **Styling:** Tailwind CSS 3.4 (Utility-first, JIT engine, Dark Mode support).

### Key Libraries & Dependencies
*   **AI Layer:** `@google/genai` (Google GenAI SDK for Gemini interactions).
*   **Visualization:** `recharts` (Composable charting library based on D3).
*   **Icons:** `lucide-react` (Lightweight, tree-shakeable SVG icons).
*   **Export Engine:** `jspdf` (Client-side PDF generation).

### Infrastructure
*   **Hosting Strategy:** Static Edge Hosting (e.g., Vercel/Netlify) or CDN.
*   **Data Storage:** Client-side `localStorage` (NoSQL-like structure via JSON serialization).

---

## 4. Architectural Patterns

### Component-Based Architecture
The application follows Atomic Design principles:
*   **Atoms:** Buttons, Icons, Badges.
*   **Molecules:** `IdeaCard`, `AdMobBanner`.
*   **Organisms:** `AnalysisView`, `ComparisonModal`.
*   **Templates/Pages:** `App.tsx` handling the main dashboard layout.

### Service-Oriented Architecture (SOA) - Client Side
API logic is strictly decoupled from UI components.
*   **`services/geminiService.ts`:** Handles all API handshake, error parsing, and prompt engineering. This allows for easy swapping of models without refactoring UI components.

### Context API for State Management
We utilize React Context (`AuthContext.tsx`) to manage global state:
*   User Authentication (Mock/Local).
*   Credits/Token usage.
*   Saved Ideas persistence.
*   This avoids prop-drilling while maintaining a lightweight footprint compared to Redux.

### Hybrid Mobile Bridge
The application detects its environment via the `window` object to toggle features:
*   **Web Mode:** Simulation of Ads.
*   **Android Mode:** Calls `window.Android.showInterstitial()` via JavaScript Interface.
*   **iOS Mode:** Calls `window.webkit.messageHandlers` for native parity.

---

## 5. Performance Optimization Techniques

### Code Splitting & Lazy Loading
To reduce the Initial Contentful Paint (ICP), heavy components are loaded asynchronously:
```typescript
const AnalysisView = React.lazy(() => import('./components/AnalysisView').then(module => ({ default: module.AnalysisView })));
// Wrapped in <Suspense fallback={<Loader />}>
```

### Memoization
*   **`React.memo`:** Applied to `IdeaCard.tsx` to prevent re-rendering the entire list when only one item changes.
*   **`useMemo`:** Used for sorting and filtering logic in `App.tsx` to avoid recalculating arrays on every keystroke.
*   **`useCallback`:** Used for event handlers passed to children to maintain referential equality.

### Asset Optimization
*   Images generated by AI are Base64 encoded but handled with `loading="lazy"` attributes.
*   Vector icons (Lucide) are used instead of raster images to ensure resolution independence and low bandwidth usage.

---

## 6. Security Protocols

### API Key Management
*   **Implementation:** Keys are accessed via `process.env.API_KEY` to be compatible with the environment injection.
*   **Runtime Checks:** The `geminiService` includes explicit checks to throw meaningful errors if the key is missing or invalid, preventing silent failures.

### Input Sanitization
*   User inputs sent to the AI are truncated (max 1000 characters) in `geminiService.ts` to prevent context-window overflow attacks or prompt injection costs.

### XSS Prevention
*   React's default string escaping is utilized.
*   `dangerouslySetInnerHTML` is strictly avoided throughout the codebase.

---

## 7. Compliance & Privacy

### GDPR & CCPA (Local-First Strategy)
Strategia-X is architected to minimize liability:
*   **Data Sovereignty:** User data (ideas, profiles) resides solely in the user's browser `localStorage`. We do not transmit this data to a central database.
*   **AI Ephemerality:** Data sent to Gemini is for processing only; we do not store request logs containing PII.
*   **Cookie Consent:** A dedicated `CookieConsent.tsx` component manages opt-in/opt-out states for local persistence.

---

## 8. Accessibility (a11y)

*   **Semantic HTML:** Usage of `<header>`, `<main>`, `<section>`, and `<footer>` tags.
*   **ARIA Roles:** Used in Modals (`role="dialog"`) and Cookie Consent (`role="region"`).
*   **Color Contrast:** Dark mode and Light mode palettes are tuned to meet WCAG AA standards.
*   **Keyboard Navigation:** All interactive elements (Buttons, Inputs) are focusable and reachable via Tab.

---

## 9. Error Handling Methodology

### Service Level
`geminiService.ts` implements try/catch blocks that normalize upstream API errors into user-friendly messages:
*   Detects Quota Exceeded (429).
*   Detects API Key issues (403).
*   Returns null/safe fallbacks to prevent UI crashes ("White Screen of Death").

### UI Level
*   **Notification System:** A Global Toast system (`NotificationToast.tsx`) provides feedback for both success and error states.
*   **Empty States:** Robust handling of empty arrays in lists and charts to show "No Data" UI instead of broken layouts.
*   **Loading States:** Skeleton loaders and spinners provide feedback during asynchronous operations (AI generation).

---

## 10. Development Workflow & Standards

### File Structure
```
/src
  /components    # Reusable UI elements (Atoms/Molecules)
  /contexts      # Global State Providers
  /services      # External API Logic
  /types         # TypeScript Interfaces
  /documentation # Project Guides
```

### Naming Conventions
*   **Files:** PascalCase for React Components (`IdeaCard.tsx`), camelCase for utilities (`geminiService.ts`).
*   **Interfaces:** PascalCase (`AppIdea`, `User`).
*   **Variables:** camelCase, descriptive (`isProMember`, `loadingAnalysis`).

### Git Workflow (Recommended)
*   **Main:** Production-ready code.
*   **Feature Branches:** `feature/swot-analysis`, `fix/chart-rendering`.
*   **Commit Messages:** Semantic commits (e.g., `feat: add PDF export`, `fix: resolve dark mode contrast`).
